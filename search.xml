<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenCV中用到的一些函数说明</title>
    <url>/2022/05/01/OpenCV%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="取整函数">取整函数</h2>
<p>cvRound()、cvFloor()、cvCeil()函数</p>
<ul>
<li>cvRound(): 返回参数最接近的整数值，四舍五入；</li>
<li>cvFloor(): 返回不大于参数的最大整数值，即向下取整；</li>
<li>cvCeil(): 返回不小于参数的最小整数值，即向上取整；</li>
</ul>
<p>示例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;cvRound(2.5) : &quot; &lt;&lt; cvRound(2.5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;cvFloor(2.5) : &quot; &lt;&lt; cvFloor(2.5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;cvCeil(2.5)  : &quot; &lt;&lt; cvCeil(2.5)  &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;cvRound(2.5) : &quot; &lt;&lt; cvRound(2.5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;cvFloor(2.5) : &quot; &lt;&lt; cvFloor(2.5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;cvCeil(2.5)  : &quot; &lt;&lt; cvCeil(2.5)  &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    waitKey(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果如下</p>
<figure>
<img src="/2022/05/01/OpenCV%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/1.png" alt="opencv"><figcaption aria-hidden="true">opencv</figcaption>
</figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>五一假期产生的一些感想</title>
    <url>/2022/05/04/%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉系列（一）：图像金字塔</title>
    <url>/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/</url>
    <content><![CDATA[<h2 id="图像金字塔">图像金字塔</h2>
<p>一幅图像的金字塔是一系列以金字塔形状排列，分辨率逐渐降低且源于同一张原始图的图像集合。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。层级越高，图像越小，分辨率越低。图像金字塔是图像中多尺度表达的一种，最初用于机器视觉和图像压缩，最主要功能用于图像分割，是一种以多分辨率来解释图像的有效但概念简单的结构。</p>
<figure>
<img src="/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/1.jpg" alt="pyramid"><figcaption aria-hidden="true">pyramid</figcaption>
</figure>
<p>生成图像金字塔主要有两种方式： <strong>向下采样</strong>和<strong>向上采样</strong>。</p>
<ul>
<li>向下采样：将图像从最底层（即上图中的level0）转换为level1、level2...的过程，图像分辨率不断降低。</li>
<li>向上采样：将图像从最顶层（即上图中的level4）转换为level3、level2...的过程，图像分辨率不断增大。</li>
</ul>
<p>常见的金字塔一般有两类：</p>
<ul>
<li><strong>高斯金字塔</strong>: 用来向下/降采样，主要的图像金字塔；</li>
<li><strong>拉普拉斯金字塔</strong>: 用来从金字塔低层图像重建上层未采样图像，在数字图像处理中也即是预测残差，可以对图像进行最大程度的还原，配合高斯金字塔一起使用。</li>
</ul>
<p>在OpenCv中提供了对图像进行上下采样的接口：<strong>pyrUp()</strong>和<strong>pyrDown()</strong>，同时提供了一个对图像进行尺度变换的函数<strong>resize()</strong>。</p>
<p>获取金字塔一般来说包括两个步骤：</p>
<ul>
<li>对于向下采样，首先对图像进行高斯平滑，然后进行降采样（将图像尺寸行和列方向缩减一半）；</li>
<li>对于向上采样，首先对图像进行升采样（将图像尺寸行和列方向增大一倍），然后进行高斯平滑；</li>
</ul>
]]></content>
      <categories>
        <category>Computer Version</category>
      </categories>
      <tags>
        <tag>Computer Version</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉系列（二）：图像梯度</title>
    <url>/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="图像梯度的概念">图像梯度的概念</h2>
<p>图像梯度是指图像某像素在x和y两个方向上的变化率（与相邻像素比较），是一个二维向量，由2个分量组成X轴的变化、Y轴的变化。其中：</p>
<ul>
<li>X轴的变化是指当前像素右侧（X加1）的像素值减去当前像素左侧（X减1）的像素值；</li>
<li>Y轴的变化是当前像素下方（Y加1）的像素值减去当前像素上方（Y减1）的像素值； 计算出来这两个分量，会形成一个二维向量，该向量描述了当前像素点的梯度。对这个向量取反正切函数 <strong><em>arctan</em></strong> ，可以得到梯度的角度。</li>
</ul>
<h2 id="图像梯度的求解">图像梯度的求解</h2>
<p>图像梯度的求解过程可以用一个卷积核来实现：[-1,0,1]。</p>
<p><span class="math inline">\(\nabla{f(x,y)}=\)</span> <span class="math inline">\(\left [ \begin{matrix} g_x\\g_y \end{matrix} \right]=\)</span> <span class="math inline">\(\left [ \begin{matrix} \frac{\partial f}{\partial x}\\ \frac{\partial f}{\partial y} \end{matrix} \right]=\)</span> <span class="math inline">\(\left [ \begin{matrix} f(x+1,y)-f(x-1,y)\\f(x,y+1)-f(x,y-1) \end{matrix} \right]\)</span></p>
<figure>
<img src="/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/2.png" alt="gradient"><figcaption aria-hidden="true">gradient</figcaption>
</figure>
<p><span class="math inline">\(\nabla{f(x,y)}=\)</span> <span class="math inline">\(\left [ \begin{matrix} f(x+1,y)-f(x-1,y)\\f(x,y+1)-f(x,y-1) \end{matrix} \right]=\)</span> <span class="math inline">\(\left [ \begin{matrix} 55-105\\90-40 \end{matrix} \right]=\)</span> <span class="math inline">\(\left [ \begin{matrix} -50\\ 50 \end{matrix} \right]\)</span></p>
<p>图像梯度的绝对值为：</p>
<p><span class="math inline">\(\sqrt{50^2+(-50)^2}=70.7107\)</span></p>
<p>图像梯度的角度为：</p>
<p><span class="math inline">\(\arctan(-50/50)=-45^\circ\)</span></p>
]]></content>
      <categories>
        <category>Computer Version</category>
      </categories>
      <tags>
        <tag>Computer Version</tag>
      </tags>
  </entry>
</search>
